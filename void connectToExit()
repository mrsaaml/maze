private void connectToExit() {
    // Simple BFS to ensure exit is reachable
    boolean[][] visited = new boolean[rows][cols];  // Array to keep track of visited cells
    Stack<Cell> stack = new Stack<>();  // Stack for DFS search
    stack.push(start);  // Start the search from the start cell
    visited[start.row][start.col] = true;

    // Perform DFS to search for a path to the exit
    while (!stack.isEmpty()) {
        Cell current = stack.pop();

        // If exit is found, the maze is solvable, so return
        if (current.equals(exit)) {
            return;
        }

        // Explore all directions (up, right, down, left)
        for (int[] dir : directions) {
            int newRow = current.row + dir[0];
            int newCol = current.col + dir[1];

            // Check if the next cell is valid, unvisited, and a path
            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols
                    && grid[newRow][newCol] == 0 && !visited[newRow][newCol]) {
                visited[newRow][newCol] = true;
                stack.push(new Cell(newRow, newCol));
            }
        }
    }

    // If exit wasn't reachable, carve a path to it
    grid[exit.row][exit.col] = 0;
    grid[exit.row - 1][exit.col] = 0;
}
